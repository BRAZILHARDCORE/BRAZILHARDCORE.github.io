<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport settings for a true full-screen mobile experience -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bui Project - The Adventure (Mobile)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Reset margins and padding for a full-screen experience */
        html, body {
            background-color: #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        .game-container {
            border: none;
            border-radius: 0;
            background-color: #000;
            padding: 0;
            box-shadow: none;
            position: relative;
            width: 100vw; /* Fill width */
            height: 100vh; /* Fill height */
            box-sizing: border-box;
            display: block; /* Will be controlled by JS */
        }

        canvas {
            background-color: #0d0d0d;
            display: block;
            border: none;
            border-radius: 0;
            cursor: pointer;
            width: 100%; /* Canvas fills container */
            height: 100%; /* Canvas fills container */
            touch-action: none; /* Disable double-tap zoom etc. */
        }
        
        /* This is the "Flip your phone" message screen */
        #rotate-overlay {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            background-color: #000;
            color: #fff;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            line-height: 1.5;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- New overlay for landscape orientation -->
    <div id="rotate-overlay">
        Please rotate your<br>phone to portrait mode.
    </div>

    <div class="game-container" id="game-container">
        <!-- Canvas width and height will be set by JavaScript -->
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const rotateOverlay = document.getElementById('rotate-overlay');
    const gameContainer = document.getElementById('game-container');

    // --- Base coordinate system (PORTRAIT) ---
    const baseWidth = 800;
    const baseHeight = 1200;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;


    // --- Image Preloading ---
    let imgGreyscale = new Image();
    let imgAlbanian = new Image();
    let imgButter = new Image();
    let imagesLoaded = { greyscale: false, albanian: false, butter: false };

    const urls = {
        internet: "https://ik.imagekit.io/ex6ksvxsvk/greyscale?updatedAt=1761322387216",
        albanian: "https://ik.imagekit.io/ex6ksvxsvk/secretly%20albanian?updatedAt=17613223716226",
        lost: "https://ik.imagekit.io/ex6ksvxsvk/butter?updatedAt=1761322400651"
    };
    
    imgGreyscale.onerror = () => { console.error("Failed to load Greyscale image."); imagesLoaded.greyscale = 'error'; };
    imgAlbanian.onerror = () => { console.error("Failed to load Albanian image."); imagesLoaded.albanian = 'error'; };
    imgButter.onerror = () => { console.error("Failed to load Butter image."); imagesLoaded.butter = 'error'; };

    imgGreyscale.onload = () => { console.log("Greyscale image loaded."); imagesLoaded.greyscale = true; };
    imgAlbanian.onload = () => { console.log("Albanian image loaded."); imagesLoaded.albanian = true; };
    imgButter.onload = () => { console.log("Butter image loaded."); imagesLoaded.butter = true; };

    imgGreyscale.src = urls.internet;
    imgAlbanian.src = urls.albanian;
    imgButter.src = urls.lost;


    // --- Game States & Data ---
    const GAME_STATES = {
        START: 'START',
        Q1: 'Q1',
        Q2: 'Q2',
        Q3: 'Q3',
        END_FAIL: 'END_FAIL',
        END_INTERNET: 'END_INTERNET',
        END_LOST: 'END_LOST',
        END_ALBANIAN: 'END_ALBANIAN'
    };
    let gameState = GAME_STATES.START;
    let hoverTarget = null;
    let animationState = {};
    let clickRegions = {};
    let isGameActive = true;

    // --- Canvas Setup, Scaling, and Orientation Check ---
    function setupCanvasAndOrientation() {
        // Check if it's a mobile device (has touch points) before checking orientation
        const isMobileDevice = navigator.maxTouchPoints > 0;

        // Check orientation first
        if (isMobileDevice && window.innerWidth > window.innerHeight) {
            // Landscape on a mobile device
            rotateOverlay.style.display = 'flex';
            gameContainer.style.display = 'none';
            isGameActive = false;
        } else {
            // Portrait
            rotateOverlay.style.display = 'none';
            gameContainer.style.display = 'block';
            isGameActive = true;

            // Set canvas to physical pixel size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Calculate scale to fit and maintain aspect ratio
            scale = Math.min(canvas.width / baseWidth, canvas.height / baseHeight);

            // Calculate centered offsets
            const newWidth = baseWidth * scale;
            const newHeight = baseHeight * scale;
            offsetX = (canvas.width - newWidth) / 2;
            offsetY = (canvas.height - newHeight) / 2;
        }
    }
    
    function setRegions(regions) {
        clickRegions[gameState] = regions;
    }

    function initializeGame() {
        animationState = { frame: 0 };
        gameState = GAME_STATES.START;
    }

    // --- Drawing Assets (using 800x1200 coordinate system) ---
    function drawInternetAddict(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        ctx.fillStyle = '#888888';
        ctx.fillRect(50, 50, 100, 150); // Body
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2); // Head
        ctx.fill();

        const glowAlpha = Math.abs(Math.sin(frame * 0.05));
        ctx.shadowColor = `rgba(0, 255, 0, ${glowAlpha})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(160, 100, 30, 50);
        ctx.shadowBlur = 0; 

        ctx.fillStyle = '#008800'; 
        ctx.fillRect(165, 105, 20, 40); 

        ctx.strokeStyle = `rgba(200, 200, 255, 0.6)`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(100, 25);
        
        const phoneCenterX = 160 + 15;
        const phoneCenterY = 100 + 25;
        const numSegments = 30;
        for (let i = 0; i <= numSegments; i++) {
            const t = i / numSegments;
            const currentX = 100 + (phoneCenterX - 100) * t;
            const currentY = 25 + (phoneCenterY - 25) * t;
            const wave = Math.sin((i * 0.5) + frame * 0.1) * (1 - t) * 10;
            ctx.lineTo(currentX + wave, currentY);
        }
        ctx.stroke();
        
        ctx.restore();
        drawText("Addicted to the internet", x + 100, y + 230, 14);
    }

    function drawLost(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        const phase = (frame % 300);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(50, 50, 100, 150);
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2);
        ctx.fill();

        if (phase < 100) {
            ctx.fillStyle = '#00FF00';
            const pillY = 100 - (phase * 0.8);
            ctx.fillRect(110, pillY, 15, 10);
        } else {
            const glowAlpha = Math.abs(Math.sin(frame * 0.1));
            ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
            ctx.beginPath();
            ctx.arc(90, 20, 8, 0, Math.PI * 2);
            ctx.arc(110, 20, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(90, 20, 4, 0, Math.PI * 2);
            ctx.arc(110, 20, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
        drawText("Lost", x + 100, y + 230, 14);
    }

    function drawAlbanianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, 10, 200);
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.moveTo(10, 10);
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130);
        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#000000';
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10;
        const cx = 10 + 100;
        const cy = 10 + waveOffset + 65;
        ctx.beginPath();
        ctx.fillRect(cx - 10, cy - 15, 20, 30);
        ctx.fillRect(cx - 25, cy - 35, 15, 20);
        ctx.fillRect(cx + 10, cy - 35, 15, 20);
        ctx.fillRect(cx - 30, cy - 30, 5, 5);
        ctx.fillRect(cx + 25, cy - 30, 5, 5);
        ctx.moveTo(cx - 10, cy - 10); ctx.lineTo(cx - 50, cy - 30); ctx.lineTo(cx - 40, cy + 20); ctx.closePath();
        ctx.moveTo(cx + 10, cy - 10); ctx.lineTo(cx + 50, cy - 30); ctx.lineTo(cx + 40, cy + 20); ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function drawBrazilianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, 10, 200);
        ctx.beginPath();
        ctx.moveTo(10, 10);
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130);
        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }
        ctx.closePath();
        ctx.fillStyle = '#009739';
        ctx.fill();
        const rhombusCX = 10 + 100;
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10;
        const rhombusCY = 10 + 65 + waveOffset; 
        const widthFactor = 0.8;
        const heightFactor = 0.8;
        ctx.fillStyle = '#FFDD00';
        ctx.beginPath();
        ctx.moveTo(rhombusCX, rhombusCY - (65 * heightFactor));
        ctx.lineTo(rhombusCX + (100 * widthFactor), rhombusCY);
        ctx.lineTo(rhombusCX, rhombusCY + (65 * heightFactor));
        ctx.lineTo(rhombusCX - (100 * widthFactor), rhombusCY);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#012169';
        ctx.beginPath();
        ctx.arc(rhombusCX, rhombusCY, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(rhombusCX - 40, rhombusCY - 5, 80, 10);
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(rhombusCX - 20, rhombusCY - 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 15, rhombusCY - 10, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX - 10, rhombusCY + 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 25, rhombusCY + 25, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // --- Helper function to draw "contain" image ---
    function drawImageContain(img) {
        const hRatio = baseWidth / img.width;
        const vRatio = baseHeight / img.height;
        const ratio = Math.min(hRatio, vRatio); // Use min for "contain"
        const centerShiftX = (baseWidth - img.width * ratio) / 2;
        const centerShiftY = (baseHeight - img.height * ratio) / 2;
        ctx.drawImage(img, 0, 0, img.width, img.height,
                      centerShiftX, centerShiftY, img.width * ratio, img.height * ratio);
    }

    // --- State Drawing Functions (Portrait Layout) ---
    function drawStartScreen() {
        drawText("ARE YOU READY?", baseWidth / 2, 400, 40); // Centered text
        const btn = { id: 'start', text: 'Fuck no', x: 150, y: 550, w: 500, h: 100 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawQ1Screen() {
        drawText("ARE YOU HARDCORE.", baseWidth / 2, 400, 32);
        const btnYes = { id: 'yes', text: 'YES', x: 150, y: 550, w: 500, h: 100 };
        const btnNo = { id: 'no', text: 'NO', x: 150, y: 670, w: 500, h: 100 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ2Screen() {
        drawText("ARE YOU THE BADDEST OF THEM ALL.", baseWidth / 2, 400, 32);
        const btnYes = { id: 'yes', text: 'YES', x: 150, y: 550, w: 500, h: 100 };
        const btnNo = { id: 'no', text: 'NO', x: 150, y: 670, w: 500, h: 100 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ3Screen() {
        drawText("ARE YOU:", baseWidth / 2, 100, 32);

        const regionWidth = 200;
        const regionHeight = 230;
        const centerX = (baseWidth - regionWidth) / 2; // 300

        const regions = [
            { id: 'internet', x: centerX, y: 200, w: regionWidth, h: regionHeight },
            { id: 'albanian', x: centerX, y: 450, w: regionWidth, h: regionHeight },
            { id: 'lost', x: centerX, y: 700, w: regionWidth, h: regionHeight },
        ];

        drawInternetAddict(regions[0].x, regions[0].y, animationState.frame);

        if (Math.random() < 0.15) {
            drawAlbanianFlag(regions[1].x, regions[1].y, animationState.frame);
        } else {
            drawBrazilianFlag(regions[1].x, regions[1].y, animationState.frame);
        }
        drawText("Secretly Albanian", regions[1].x + 100, regions[1].y + 230, 14);

        drawLost(regions[2].x, regions[2].y, animationState.frame);

        regions.forEach(region => {
            if (hoverTarget === region.id) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.strokeRect(region.x - 10, region.y - 10, region.w + 20, region.h + 20);
            }
        });
        
        setRegions(regions);
    }
    
    // --- End Screens (All updated with both buttons) ---

    function drawEndFailScreen() {
        drawText("Sorry, you can't continue.", baseWidth / 2, 400, 32);
        const btnRestart = { id: 'restart', text: 'restart', x: 150, y: 550, w: 500, h: 100 };
        const btnReady = { id: 'ready', text: 'I am ready now', x: 150, y: 670, w: 500, h: 100 };
        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id);
        setRegions([btnRestart, btnReady]);
    }
    
    function drawEndInternetScreen() {
        if (imagesLoaded.greyscale === true) {
            drawImageContain(imgGreyscale);
        } else if (imagesLoaded.greyscale === 'error') {
            drawText("Error loading Greyscale", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading Greyscale...", baseWidth / 2, 300, 32);
        }
        const btnRestart = { id: 'restart', text: 'restart', x: 150, y: 900, w: 500, h: 100 };
        const btnReady = { id: 'ready', text: 'I am ready now', x: 150, y: 1020, w: 500, h: 100 };
        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id);
        setRegions([btnRestart, btnReady]);
    }

    function drawEndLostScreen() {
        if (imagesLoaded.butter === true) {
            drawImageContain(imgButter);
        } else if (imagesLoaded.butter === 'error') {
            drawText("Error loading butter", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading butter...", baseWidth / 2, 300, 32);
        }
        const btnRestart = { id: 'restart', text: 'restart', x: 150, y: 900, w: 500, h: 100 };
        const btnReady = { id: 'ready', text: 'I am ready now', x: 150, y: 1020, w: 500, h: 100 };
        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id);
        setRegions([btnRestart, btnReady]);
    }

    function drawEndAlbanianScreen() {
        if (imagesLoaded.albanian === true) {
            drawImageContain(imgAlbanian);
        } else if (imagesLoaded.albanian === 'error') {
            drawText("Error loading albanian", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading albanian...", baseWidth / 2, 300, 32);
        }
        const btnRestart = { id: 'restart', text: 'restart', x: 150, y: 900, w: 500, h: 100 };
        const btnReady = { id: 'ready', text: 'I am ready now', x: 150, y: 1020, w: 500, h: 100 };
        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id);
        setRegions([btnRestart, btnReady]);
    }

    // --- Core Logic ---
    function gameLoop() {
        if (!isGameActive) {
            // Don't draw if in landscape
            requestAnimationFrame(gameLoop); // Keep looping to check for orientation change
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // --- Draw game elements inside the 800x1200 coordinate system ---
        animationState.frame++;
        switch (gameState) {
            case GAME_STATES.START: drawStartScreen(); break;
            case GAME_STATES.Q1: drawQ1Screen(); break;
            case GAME_STATES.Q2: drawQ2Screen(); break;
            case GAME_STATES.Q3: drawQ3Screen(); break;
            case GAME_STATES.END_FAIL: drawEndFailScreen(); break;
            case GAME_STATES.END_INTERNET: drawEndInternetScreen(); break;
            case GAME_STATES.END_LOST: drawEndLostScreen(); break;
            case GAME_STATES.END_ALBANIAN: drawEndAlbanianScreen(); break;
        }

        ctx.restore();
        
        requestAnimationFrame(gameLoop);
    }
    
    // --- Event Handlers (Updated for Scaling and Touch) ---
    function getTransformedCoords(event) {
        // Removed event.preventDefault() from here to fix touch bug
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (event.type.startsWith('touch')) {
            clientX = (event.touches[0] || event.changedTouches[0]).clientX;
            clientY = (event.touches[0] || event.changedTouches[0]).clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        const mouseX_raw = clientX - rect.left;
        const mouseY_raw = clientY - rect.top;

        const mouseX = (mouseX_raw - offsetX) / scale;
        const mouseY = (mouseY_raw - offsetY) / scale;

        return { mouseX, mouseY };
    }

    function handleInteraction(event) {
        if (!isGameActive) return;

        // Prevent default touch behaviors (like zoom) only when interacting
        if (event.type === 'touchstart') {
            event.preventDefault();
        }
        
        const { mouseX, mouseY } = getTransformedCoords(event);

        const regions = clickRegions[gameState] || [];
        for (const region of regions) {
            if (mouseX >= region.x && mouseX <= region.x + region.w &&
                mouseY >= region.y && mouseY <= region.y + region.h) {
                
                switch(gameState) {
                    case GAME_STATES.START:
                        if (region.id === 'start') gameState = GAME_STATES.Q1;
                        break;
                    case GAME_STATES.Q1:
                        if (region.id === 'yes') gameState = GAME_STATES.Q2;
                        else if (region.id === 'no') gameState = GAME_STATES.END_FAIL;
                        break;
                    case GAME_STATES.Q2:
                        if (region.id === 'yes') gameState = GAME_STATES.Q3;
                        else if (region.id === 'no') gameState = GAME_STATES.END_FAIL;
                        break;
                    case GAME_STATES.Q3:
                        if (region.id === 'internet') gameState = GAME_STATES.END_INTERNET;
                        else if (region.id === 'lost') gameState = GAME_STATES.END_LOST;
                        else if (region.id === 'albanian') gameState = GAME_STATES.END_ALBANIAN;
                        break;
                    case GAME_STATES.END_FAIL:
                    case GAME_STATES.END_INTERNET:
                    case GAME_STATES.END_LOST:
                    case GAME_STATES.END_ALBANIAN:
                        if (region.id === 'restart') {
                            initializeGame();
                        } else if (region.id === 'ready') {
                            window.location.href = 'https://www.shopify.com/de';
                        }
                        break;
                }
                return;
            }
        }
    }
    
    function drawButton(text, x, y, w, h, isHovered, isDone, id = null) {
        ctx.strokeStyle = '#fff';
        if(isDone) ctx.fillStyle = '#00ff00';
        else ctx.fillStyle = isHovered ? '#00ff00' : '#555';
        ctx.fillRect(x,y,w,h);
        ctx.strokeRect(x,y,w,h);
        
        let fontSize = 24; // Good default for large buttons
        if(text.length > 10) fontSize = 20;
        if(text.length > 15) fontSize = 16; // Adjust for "I am ready now"

        drawText(text, x + w/2, y + h/2 + 4, fontSize, isHovered || isDone ? '#000' : '#fff');
    }
    
    function drawText(text, x, y, size = 32, color = '#fff') {
            ctx.font = `${size}px "Press Start 2P"`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const maxWidth = baseWidth - 100; // 50px padding
            if(ctx.measureText(text).width > maxWidth && text.includes(' ')) {
                const words = text.split(' ');
                let line = '';
                let yOffset = 0;
                // Adjust starting Y for multi-line text to keep it centered
                const linesNeeded = Math.ceil(ctx.measureText(text).width / (maxWidth / 1.5)); // Rough estimate
                if (linesNeeded > 1) {
                    yOffset -= (size * (linesNeeded - 1)) / 2;
                }

                for(let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    if (ctx.measureText(testLine).width > maxWidth && n > 0) {
                        ctx.fillText(line, x, y + yOffset);
                        line = words[n] + ' ';
                        yOffset += size + 4;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y + yOffset);
            } else {
                ctx.fillText(text, x, y);
            }
    }
    
    function handleMouseMove(event) {
        if (!isGameActive) return;
        
        const { mouseX, mouseY } = getTransformedCoords(event);
        const regions = clickRegions[gameState] || [];
        hoverTarget = null;
        canvas.style.cursor = 'default';
        for (const region of regions) {
             if (mouseX >= region.x && mouseX <= region.x + region.w &&
                 mouseY >= region.y && mouseY <= region.y + region.h) {
                 hoverTarget = region.id;
                 canvas.style.cursor = 'pointer';
                 break;
             }
        }
    }

    // --- Initial Setup ---
    canvas.addEventListener('click', handleInteraction);
    canvas.addEventListener('touchstart', handleInteraction, { passive: false });

    // Mousemove for hover (desktop debugging)
    canvas.addEventListener('mousemove', handleMouseMove);

    // Check orientation on resize
    window.addEventListener('resize', setupCanvasAndOrientation);

    // Initial setup
    setupCanvasAndOrientation(); 
    initializeGame();
    gameLoop();

</script>

</body>
</html>


