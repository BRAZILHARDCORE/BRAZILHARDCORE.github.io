
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bui Project - The Adventure (Mobile)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Reset margins and padding for a full-screen experience */
        html, body {
            background-color: #000;
            color: #fff;
            font-family: 'Press+Start+2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        .game-container {
            border: none; /* Remove desktop border */
            border-radius: 0;
            background-color: #000;
            padding: 0;
            box-shadow: none; /* Remove desktop shadow */
            position: relative;
            width: 100vw; /* Fill width */
            height: 100vh; /* Fill height */
            box-sizing: border-box;
        }

        canvas {
            background-color: #0d0d0d;
            display: block;
            border: none;
            border-radius: 0;
            cursor: pointer;
            width: 100%; /* Canvas fills container */
            height: 100%; /* Canvas fills container */
            touch-action: none; /* Disable double-tap zoom etc. */
        }
        
    </style>
</head>
<body>
    <div class="game-container" id="game-container">
        <!-- Canvas width and height will be set by JavaScript -->
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Base coordinate system ---
    const baseWidth = 1200;
    const baseHeight = 800;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;


    // --- Image Preloading ---
    let imgGreyscale = new Image();
    let imgAlbanian = new Image();
    let imgButter = new Image();
    let imagesLoaded = { greyscale: false, albanian: false, butter: false };

    const urls = {
        internet: "https://ik.imagekit.io/ex6ksvxsvk/greyscale?updatedAt=1761322387216",
        albanian: "https://ik.imagekit.io/ex6ksvxsvk/secretly%20albanian?updatedAt=17613223716226",
        lost: "https://ik.imagekit.io/ex6ksvxsvk/butter?updatedAt=1761322400651"
    };
    
    // Set error handlers
    imgGreyscale.onerror = () => { console.error("Failed to load Greyscale image."); imagesLoaded.greyscale = 'error'; };
    imgAlbanian.onerror = () => { console.error("Failed to load Albanian image."); imagesLoaded.albanian = 'error'; };
    imgButter.onerror = () => { console.error("Failed to load Butter image."); imagesLoaded.butter = 'error'; };

    // Set onload handlers
    imgGreyscale.onload = () => { console.log("Greyscale image loaded."); imagesLoaded.greyscale = true; };
    imgAlbanian.onload = () => { console.log("Albanian image loaded."); imagesLoaded.albanian = true; };
    imgButter.onload = () => { console.log("Butter image loaded."); imagesLoaded.butter = true; };

    // Set src to start loading
    imgGreyscale.src = urls.internet;
    imgAlbanian.src = urls.albanian;
    imgButter.src = urls.lost;


    // --- Game States & Data ---
    const GAME_STATES = {
        START: 'START',
        Q1: 'Q1',
        Q2: 'Q2',
        Q3: 'Q3',
        END_FAIL: 'END_FAIL',
        END_INTERNET: 'END_INTERNET',
        END_LOST: 'END_LOST',
        END_ALBANIAN: 'END_ALBANIAN'
    };
    let gameState = GAME_STATES.START;
    let hoverTarget = null;
    let animationState = {};
    let clickRegions = {};
    let isGameActive = true;

    // --- Canvas Setup and Scaling ---
    function setupCanvas() {
        // Set canvas to physical pixel size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Calculate scale to fit and maintain aspect ratio
        scale = Math.min(canvas.width / baseWidth, canvas.height / baseHeight);

        // Calculate centered offsets
        const newWidth = baseWidth * scale;
        const newHeight = baseHeight * scale;
        offsetX = (canvas.width - newWidth) / 2;
        offsetY = (canvas.height - newHeight) / 2;
    }
    
    function setRegions(regions) {
        clickRegions[gameState] = regions;
    }

    function initializeGame() {
        animationState = { frame: 0 };
        gameState = GAME_STATES.START;
    }

    // --- Drawing Assets ---
    // (All drawing functions remain the same as they use the 1200x800 coordinate system)

    function drawInternetAddict(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        // Grey character
        ctx.fillStyle = '#888888';
        ctx.fillRect(50, 50, 100, 150); // Body
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2); // Head
        ctx.fill();

        // Phone
        // Apply glowing effect to phone
        const glowAlpha = Math.abs(Math.sin(frame * 0.05)); // Pulsating glow
        ctx.shadowColor = `rgba(0, 255, 0, ${glowAlpha})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#00ff00'; // Neon green for the glowing phone
        ctx.fillRect(160, 100, 30, 50); // Phone body
        ctx.shadowBlur = 0; // Reset shadow for other drawings

        // Phone screen (darker green inside the glowing phone)
        ctx.fillStyle = '#008800'; 
        ctx.fillRect(165, 105, 20, 40); 

        // Soul stream
        ctx.strokeStyle = `rgba(200, 200, 255, 0.6)`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(100, 25); // From character's head
        
        // Connect to the phone
        const phoneCenterX = 160 + 15;
        const phoneCenterY = 100 + 25;
        const numSegments = 30;
        for (let i = 0; i <= numSegments; i++) {
            const t = i / numSegments;
            const currentX = 100 + (phoneCenterX - 100) * t;
            const currentY = 25 + (phoneCenterY - 25) * t;
            const wave = Math.sin((i * 0.5) + frame * 0.1) * (1 - t) * 10; // Wave decreases as it reaches the phone
            ctx.lineTo(currentX + wave, currentY);
        }
        ctx.stroke();
        
        ctx.restore();
        drawText("Addicted to the internet", x + 100, y + 230, 14);
    }

    function drawLost(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        const phase = (frame % 300);
        
        // Character
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(50, 50, 100, 150); // Body
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2); // Head
        ctx.fill();

        if (phase < 100) {
            // Hand moving pill to mouth
            ctx.fillStyle = '#00FF00'; // Neon green pill
            const pillY = 100 - (phase * 0.8);
            ctx.fillRect(110, pillY, 15, 10);
        } else {
            // Eyes glow
            const glowAlpha = Math.abs(Math.sin(frame * 0.1));
            ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
            ctx.beginPath();
            ctx.arc(90, 20, 8, 0, Math.PI * 2);
            ctx.arc(110, 20, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(90, 20, 4, 0, Math.PI * 2);
            ctx.arc(110, 20, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
        drawText("Lost", x + 100, y + 230, 14);
    }

    function drawAlbanianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        // Pole
        ctx.fillStyle = '#8B4513'; // Brown
        ctx.fillRect(0, 0, 10, 200);

        // Waving flag
        ctx.fillStyle = '#FF0000'; // Red
        ctx.beginPath();
        ctx.moveTo(10, 10); // Top left
        
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            if(i === 0) ctx.lineTo(10 + i, 10 + wave);
            else ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130); // Top right to bottom right

        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }

        ctx.closePath();
        ctx.fill();
        
        // Simplified Eagle
        ctx.fillStyle = '#000000';
        
        // Calculate center of flag with wave
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10;
        const cx = 10 + 100; // 100 is halfway across 200 width
        const cy = 10 + waveOffset + 65; // 65 is halfway down 130 height

        // Draw eagle relative to waving center
        ctx.beginPath();
        // Body
        ctx.fillRect(cx - 10, cy - 15, 20, 30);
        // Heads
        ctx.fillRect(cx - 25, cy - 35, 15, 20);
        ctx.fillRect(cx + 10, cy - 35, 15, 20);
        // Beaks
        ctx.fillRect(cx - 30, cy - 30, 5, 5);
        ctx.fillRect(cx + 25, cy - 30, 5, 5);
        // Wings
        ctx.moveTo(cx - 10, cy - 10); ctx.lineTo(cx - 50, cy - 30); ctx.lineTo(cx - 40, cy + 20); ctx.closePath();
        ctx.moveTo(cx + 10, cy - 10); ctx.lineTo(cx + 50, cy - 30); ctx.lineTo(cx + 40, cy + 20); ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function drawBrazilianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        // Pole
        ctx.fillStyle = '#8B4513'; // Brown
        ctx.fillRect(0, 0, 10, 200);

        // Waving flag base (Green Rectangle)
        ctx.beginPath();
        ctx.moveTo(10, 10);
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            if(i === 0) ctx.lineTo(10 + i, 10 + wave);
            else ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130);
        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }
        ctx.closePath();
        ctx.fillStyle = '#009739'; // Green
        ctx.fill();
        
        // Yellow Rhombus (Diamond) - positioned relative to the wave
        const rhombusCX = 10 + 100;
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10; // Wave at center x
        const rhombusCY = 10 + 65 + waveOffset; 
        const widthFactor = 0.8;
        const heightFactor = 0.8;

        ctx.fillStyle = '#FFDD00'; // Yellow
        ctx.beginPath();
        ctx.moveTo(rhombusCX, rhombusCY - (65 * heightFactor)); // Top
        ctx.lineTo(rhombusCX + (100 * widthFactor), rhombusCY);     // Right
        ctx.lineTo(rhombusCX, rhombusCY + (65 * heightFactor)); // Bottom
        ctx.lineTo(rhombusCX - (100 * widthFactor), rhombusCY);     // Left
        ctx.closePath();
        ctx.fill();

        // Blue Circle - positioned relative to the wave
        ctx.fillStyle = '#012169'; // Dark Blue
        ctx.beginPath();
        ctx.arc(rhombusCX, rhombusCY, 40, 0, Math.PI * 2);
        ctx.fill();

        // White band (simplified) - positioned relative to the wave
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(rhombusCX - 40, rhombusCY - 5, 80, 10); // Simplified band
        
        // Stars (simplified) - positioned relative to the wave
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(rhombusCX - 20, rhombusCY - 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 15, rhombusCY - 10, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX - 10, rhombusCY + 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 25, rhombusCY + 25, 3, 0, Math.PI * 2);
        ctx.fill();


        ctx.restore();
    }


    // --- State Drawing Functions (Modified for Mobile Layout) ---
    function drawStartScreen() {
        drawText("ARE YOU READY?", baseWidth / 2, 300, 40);
        const btn = { id: 'start', text: 'Fuck no', x: baseWidth / 2 - 200, y: 450, w: 400, h: 100 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawQ1Screen() {
        drawText("ARE YOU HARDCORE.", baseWidth / 2, 300, 32);
        // Stacked buttons for mobile
        const btnYes = { id: 'yes', text: 'YES', x: baseWidth / 2 - 200, y: 400, w: 400, h: 100 };
        const btnNo = { id: 'no', text: 'NO', x: baseWidth / 2 - 200, y: 520, w: 400, h: 100 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ2Screen() {
        drawText("ARE YOU THE BADDEST OF THEM ALL.", baseWidth / 2, 300, 32);
        // Stacked buttons for mobile
        const btnYes = { id: 'yes', text: 'YES', x: baseWidth / 2 - 200, y: 400, w: 400, h: 100 };
        const btnNo = { id: 'no', text: 'NO', x: baseWidth / 2 - 200, y: 520, w: 400, h: 100 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ3Screen() {
        drawText("ARE YOU:", baseWidth / 2, 80, 32);

        // Stacked options for mobile
        const regionWidth = 200;
        const regionHeight = 230;
        const centerX = (baseWidth - regionWidth) / 2; // Center = 500

        const regions = [
            { id: 'internet', x: centerX, y: 120, w: regionWidth, h: regionHeight },
            { id: 'albanian', x: centerX, y: 350, w: regionWidth, h: regionHeight }, // Albanian/Brazilian in the middle
            { id: 'lost', x: centerX, y: 580, w: regionWidth, h: regionHeight },
        ];

        drawInternetAddict(regions[0].x, regions[0].y, animationState.frame);

        // Glitching Albanian/Brazilian flag logic - REVERSED
        if (Math.random() < 0.15) { // 15% chance to glitch to Albanian flag
            drawAlbanianFlag(regions[1].x, regions[1].y, animationState.frame);
        } else {
            drawBrazilianFlag(regions[1].x, regions[1].y, animationState.frame);
        }
        drawText("Secretly Albanian", regions[1].x + 100, regions[1].y + 230, 14);


        drawLost(regions[2].x, regions[2].y, animationState.frame);

        regions.forEach(region => {
            if (hoverTarget === region.id) {
                ctx.strokeStyle = '#00ff00'; /* Neon Green */
                ctx.lineWidth = 4;
                ctx.strokeRect(region.x - 10, region.y - 10, region.w + 20, region.h + 20);
            }
        });
        
        setRegions(regions);
    }
    
    function drawEndScreen(message) {
        drawText(message, baseWidth / 2, 300, 32);
        const btn = { id: 'restart', text: 'RESTART', x: baseWidth / 2 - 200, y: 450, w: 400, h: 100 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawEndFailScreen() {
        drawEndScreen("Sorry, you can't continue.");
    }
    
    function drawEndInternetScreen() {
        if (imagesLoaded.greyscale === true) {
            ctx.drawImage(imgGreyscale, 0, 0, baseWidth, baseHeight); // Draw to base coordinates
        } else if (imagesLoaded.greyscale === 'error') {
            drawText("Error loading Greyscale", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading Greyscale...", baseWidth / 2, 300, 32);
        }
        const btn = { id: 'restart', text: 'RESTART', x: baseWidth / 2 - 200, y: 700, w: 400, h: 80 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawEndLostScreen() {
        if (imagesLoaded.butter === true) {
            ctx.drawImage(imgButter, 0, 0, baseWidth, baseHeight);
        } else if (imagesLoaded.butter === 'error') {
            drawText("Error loading butter", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading butter...", baseWidth / 2, 300, 32);
        }
        const btn = { id: 'restart', text: 'RESTART', x: baseWidth / 2 - 200, y: 700, w: 400, h: 80 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawEndAlbanianScreen() {
        if (imagesLoaded.albanian === true) {
            ctx.drawImage(imgAlbanian, 0, 0, baseWidth, baseHeight);
        } else if (imagesLoaded.albanian === 'error') {
            drawText("Error loading albanian", baseWidth / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading albanian...", baseWidth / 2, 300, 32);
        }
        const btn = { id: 'restart', text: 'RESTART', x: baseWidth / 2 - 200, y: 700, w: 400, h: 80 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    // --- Core Logic ---
    function gameLoop() {
        if (!isGameActive) {
            return; // Stop the loop if the game is not active
        }

        // Clear the *entire* physical canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Save context, apply scaling and offset
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // --- Draw game elements inside the 1200x800 coordinate system ---
        switch (gameState) {
            case GAME_STATES.START: drawStartScreen(); break;
            case GAME_STATES.Q1: drawQ1Screen(); break;
            case GAME_STATES.Q2: drawQ2Screen(); break;
            case GAME_STATES.Q3: drawQ3Screen(); break;
            case GAME_STATES.END_FAIL: drawEndFailScreen(); break;
            case GAME_STATES.END_INTERNET: drawEndInternetScreen(); break;
            case GAME_STATES.END_LOST: drawEndLostScreen(); break;
            case GAME_STATES.END_ALBANIAN: drawEndAlbanianScreen(); break;
        }

        // Restore context to remove scaling
        ctx.restore();
        
        requestAnimationFrame(gameLoop);
    }
    
    // --- Event Handlers (Updated for Scaling and Touch) ---
    function getTransformedCoords(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (event.type.startsWith('touch')) {
            clientX = (event.touches[0] || event.changedTouches[0]).clientX;
            clientY = (event.touches[0] || event.changedTouches[0]).clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        const mouseX_raw = clientX - rect.left;
        const mouseY_raw = clientY - rect.top;

        // Reverse the scaling and offset
        const mouseX = (mouseX_raw - offsetX) / scale;
        const mouseY = (mouseY_raw - offsetY) / scale;

        return { mouseX, mouseY };
    }

    function handleClick(event) {
        if (!isGameActive) return;
        
        const { mouseX, mouseY } = getTransformedCoords(event);

        const regions = clickRegions[gameState] || [];
        for (const region of regions) {
            if (mouseX >= region.x && mouseX <= region.x + region.w &&
                mouseY >= region.y && mouseY <= region.y + region.h) {
                
                switch(gameState) {
                    case GAME_STATES.START:
                        if (region.id === 'start') gameState = GAME_STATES.Q1;
                        break;
                    case GAME_STATES.Q1:
                        if (region.id === 'yes') gameState = GAME_STATES.Q2;
                        else if (region.id === 'no') gameState = GAME_STATES.END_FAIL;
                        break;
                    case GAME_STATES.Q2:
                        if (region.id === 'yes') gameState = GAME_STATES.Q3;
                        else if (region.id === 'no') gameState = GAME_STATES.END_FAIL;
                        break;
                    case GAME_STATES.Q3:
                        if (region.id === 'internet') gameState = GAME_STATES.END_INTERNET;
                        else if (region.id === 'lost') gameState = GAME_STATES.END_LOST;
                        else if (region.id === 'albanian') gameState = GAME_STATES.END_ALBANIAN;
                        break;
                    case GAME_STATES.END_FAIL:
                    case GAME_STATES.END_INTERNET:
                    case GAME_STATES.END_LOST:
                    case GAME_STATES.END_ALBANIAN:
                        if (region.id === 'restart') initializeGame();
                        break;
                }
                return; // Exit after processing click
            }
        }
    }
    
    function drawButton(text, x, y, w, h, isHovered, isDone, id = null) {
        ctx.strokeStyle = '#fff';
        if(isDone) ctx.fillStyle = '#00ff00';
        else ctx.fillStyle = isHovered ? '#00ff00' : '#555'; /* Neon Green for hover */
        ctx.fillRect(x,y,w,h);
        ctx.strokeRect(x,y,w,h);
        
        let fontSize = 24; // Larger base font for mobile buttons
        if(text.length > 10) fontSize = 16;
        if(text.length > 20) fontSize = 12;

        drawText(text, x + w/2, y + h/2 + 4, fontSize, isHovered || isDone ? '#000' : '#fff');
    }
    
    function drawText(text, x, y, size = 32, color = '#fff') {
            ctx.font = `${size}px "Press Start 2P"`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Basic text wrapping for long titles
            const maxWidth = baseWidth - 100; // 50px padding
            if(ctx.measureText(text).width > maxWidth) {
                const words = text.split(' ');
                let line = '';
                let testLine = '';
                let yOffset = 0;
                for(let n = 0; n < words.length; n++) {
                    testLine = line + words[n] + ' ';
                    if (ctx.measureText(testLine).width > maxWidth) {
                        ctx.fillText(line, x, y + yOffset);
                        line = words[n] + ' ';
                        yOffset += size + 4; // Move to next line
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y + yOffset);
            } else {
                ctx.fillText(text, x, y);
            }
    }
    
    function handleMouseMove(event) {
        if (!isGameActive) return;
        
        const { mouseX, mouseY } = getTransformedCoords(event);

        const regions = clickRegions[gameState] || [];
        hoverTarget = null;
        canvas.style.cursor = 'default';
        for (const region of regions) {
             if (mouseX >= region.x && mouseX <= region.x + region.w &&
                 mouseY >= region.y && mouseY <= region.y + region.h) {
                 hoverTarget = region.id;
                 canvas.style.cursor = 'pointer';
                 break;
             }
        }
    }

    // --- Initial Setup ---
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('touchstart', handleClick, { passive: false }); // Use passive: false to allow preventDefault

    // Mobile doesn't really have "hover", but we'll leave mousemove for desktop/debug
    canvas.addEventListener('mousemove', handleMouseMove);
    // canvas.addEventListener('touchmove', handleMouseMove, { passive: false }); // Can be noisy, enable if hover-like behavior is needed

    window.addEventListener('resize', setupCanvas);

    setupCanvas(); // Initial setup
    initializeGame();
    gameLoop();

</script>

</body>
</html>
