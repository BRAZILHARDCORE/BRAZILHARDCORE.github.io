<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- This viewport tag is essential for mobile responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bui Project - The Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Make body fill the entire screen */
        body, html {
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        /* This container will scale down while maintaining its aspect ratio */
        .game-container {
            border: 8px solid #444;
            border-radius: 15px;
            background-color: #000;
            box-shadow: 0 0 25px #ff00ff, 0 0 15px #00ffff inset;
            position: relative;
            
            /* Sizing magic */
            width: 100%;
            height: 100%;
            /* Set max size to the game's internal resolution */
            max-width: 1200px; 
            /* Enforce the 1200/800 aspect ratio */
            aspect-ratio: 1200 / 800; 
        }

        canvas {
            background-color: #0d0d0d;
            display: block;
            border-radius: 5px;
            
            /* Make canvas fill its container */
            width: 100%;
            height: 100%;
            
            /* IMPORTANT: Prevents touch-scrolling/zooming on the canvas */
            touch-action: none; 
        }
        
        /* This is the "Flip your phone" screen */
        #rotate-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 100;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        /* This media query shows the overlay ONLY in portrait mode */
        @media (orientation: portrait) {
            #rotate-overlay {
                display: flex;
            }
            .game-container {
                display: none; /* Hide the game in portrait */
            }
        }
        
    </style>
</head>
<body>

    <!-- This overlay will show on phones in portrait mode -->
    <div id="rotate-overlay">
        <h1 style="font-size: 18px; line-height: 1.5em; color: #00ff00;">
            FLIP YOUR PHONE
        </h1>
        <p style="font-size: 14px;">(This adventure requires landscape mode)</p>
    </div>

    <!-- The game container is hidden in portrait mode by the CSS above -->
    <div class="game-container" id="game-container">
        <!-- The internal resolution is still 1200x800, but CSS scales the canvas -->
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Image Preloading ---
    let imgGreyscale = new Image();
    let imgAlbanian = new Image();
    let imgButter = new Image();
    let imagesLoaded = { greyscale: false, albanian: false, butter: false };

    const urls = {
        internet: "https://ik.imagekit.io/ex6ksvxsvk/greyscale?updatedAt=1761322387216",
        albanian: "https://ik.imagekit.io/ex6ksvxsvk/secretly%20albanian?updatedAt=17613223716226",
        lost: "https://ik.imagekit.io/ex6ksvxsvk/butter?updatedAt=1761322400651"
    };
    
    // Set error handlers
    imgGreyscale.onerror = () => { console.error("Failed to load Greyscale image."); imagesLoaded.greyscale = 'error'; };
    imgAlbanian.onerror = () => { console.error("Failed to load Albanian image."); imagesLoaded.albanian = 'error'; };
    imgButter.onerror = () => { console.error("Failed to load Butter image."); imagesLoaded.butter = 'error'; };

    // Set onload handlers
    imgGreyscale.onload = () => { console.log("Greyscale image loaded."); imagesLoaded.greyscale = true; };
    imgAlbanian.onload = () => { console.log("Albanian image loaded."); imagesLoaded.albanian = true; };
    imgButter.onload = () => { console.log("Butter image loaded."); imagesLoaded.butter = true; };

    // Set src to start loading
    imgGreyscale.src = urls.internet;
    imgAlbanian.src = urls.albanian;
    imgButter.src = urls.lost;


    // --- Game States & Data ---
    const GAME_STATES = {
        START: 'START',
        Q1: 'Q1',
        Q2: 'Q2',
        Q3: 'Q3',
        END_FAIL: 'END_FAIL',
        END_INTERNET: 'END_INTERNET',
        END_LOST: 'END_LOST',
        END_ALBANIAN: 'END_ALBANIAN'
    };
    let gameState = GAME_STATES.START;
    let hoverTarget = null;
    let animationState = {};
    let clickRegions = {};
    let isGameActive = true;
    
    function setRegions(regions) {
        clickRegions[gameState] = regions;
    }

    function initializeGame() {
        animationState = { frame: 0 };
        gameState = GAME_STATES.START;
    }

    // --- Drawing Assets ---
    // All drawing functions (drawInternetAddict, drawLost, etc.)
    // remain EXACTLY THE SAME as they draw to the internal 1200x800 canvas.

    function drawInternetAddict(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        // Grey character
        ctx.fillStyle = '#888888';
        ctx.fillRect(50, 50, 100, 150); // Body
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2); // Head
        ctx.fill();

        // Phone
        const glowAlpha = Math.abs(Math.sin(frame * 0.05)); // Pulsating glow
        ctx.shadowColor = `rgba(0, 255, 0, ${glowAlpha})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#00ff00'; // Neon green
        ctx.fillRect(160, 100, 30, 50); // Phone body
        ctx.shadowBlur = 0; 

        ctx.fillStyle = '#008800'; 
        ctx.fillRect(165, 105, 20, 40); 

        // Soul stream
        ctx.strokeStyle = `rgba(200, 200, 255, 0.6)`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(100, 25); // From head
        
        const phoneCenterX = 160 + 15;
        const phoneCenterY = 100 + 25;
        const numSegments = 30;
        for (let i = 0; i <= numSegments; i++) {
            const t = i / numSegments;
            const currentX = 100 + (phoneCenterX - 100) * t;
            const currentY = 25 + (phoneCenterY - 25) * t;
            const wave = Math.sin((i * 0.5) + frame * 0.1) * (1 - t) * 10;
            ctx.lineTo(currentX + wave, currentY);
        }
        ctx.stroke();
        
        ctx.restore();
        drawText("Addicted to the internet", x + 100, y + 230, 14);
    }

    function drawLost(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        const phase = (frame % 300);
        
        // Character
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(50, 50, 100, 150); // Body
        ctx.beginPath();
        ctx.arc(100, 25, 25, 0, Math.PI * 2); // Head
        ctx.fill();

        if (phase < 100) {
            // Hand moving pill to mouth
            ctx.fillStyle = '#00FF00'; // Neon green pill
            const pillY = 100 - (phase * 0.8);
            ctx.fillRect(110, pillY, 15, 10);
        } else {
            // Eyes glow
            const glowAlpha = Math.abs(Math.sin(frame * 0.1));
            ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
            ctx.beginPath();
            ctx.arc(90, 20, 8, 0, Math.PI * 2);
            ctx.arc(110, 20, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(90, 20, 4, 0, Math.PI * 2);
            ctx.arc(110, 20, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
        drawText("Lost", x + 100, y + 230, 14);
    }

    function drawAlbanianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#8B4513'; // Pole
        ctx.fillRect(0, 0, 10, 200);
        ctx.fillStyle = '#FF0000'; // Flag
        ctx.beginPath();
        ctx.moveTo(10, 10);
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130);
        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }
        ctx.closePath();
        ctx.fill();
        
        // Simplified Eagle
        ctx.fillStyle = '#000000';
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10;
        const cx = 10 + 100; // center x
        const cy = 10 + waveOffset + 65; // center y
        ctx.beginPath();
        ctx.fillRect(cx - 10, cy - 15, 20, 30); // Body
        ctx.fillRect(cx - 25, cy - 35, 15, 20); // Head 1
        ctx.fillRect(cx + 10, cy - 35, 15, 20); // Head 2
        ctx.fillRect(cx - 30, cy - 30, 5, 5); // Beak 1
        ctx.fillRect(cx + 25, cy - 30, 5, 5); // Beak 2
        ctx.moveTo(cx - 10, cy - 10); ctx.lineTo(cx - 50, cy - 30); ctx.lineTo(cx - 40, cy + 20); ctx.closePath();
        ctx.moveTo(cx + 10, cy - 10); ctx.lineTo(cx + 50, cy - 30); ctx.lineTo(cx + 40, cy + 20); ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function drawBrazilianFlag(x, y, frame) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#8B4513'; // Pole
        ctx.fillRect(0, 0, 10, 200);

        // Waving flag base (Green)
        ctx.beginPath();
        ctx.moveTo(10, 10);
        let wavePath = [];
        for (let i = 0; i <= 200; i+=10) {
            const wave = Math.sin((i / 50) + frame * 0.05) * 10;
            ctx.lineTo(10 + i, 10 + wave);
            wavePath.push({x: 10 + i, y: 10 + wave});
        }
        const lastWave = wavePath[wavePath.length - 1];
        ctx.lineTo(lastWave.x, lastWave.y + 130);
        for (let i = wavePath.length - 1; i >= 0; i--) {
             ctx.lineTo(wavePath[i].x, wavePath[i].y + 130);
        }
        ctx.closePath();
        ctx.fillStyle = '#009739'; // Green
        ctx.fill();
        
        // Yellow Rhombus
        const rhombusCX = 10 + 100;
        const waveOffset = Math.sin((100 / 50) + frame * 0.05) * 10;
        const rhombusCY = 10 + 65 + waveOffset; 
        const widthFactor = 0.8;
        const heightFactor = 0.8;

        ctx.fillStyle = '#FFDD00'; // Yellow
        ctx.beginPath();
        ctx.moveTo(rhombusCX, rhombusCY - (65 * heightFactor)); // Top
        ctx.lineTo(rhombusCX + (100 * widthFactor), rhombusCY);   // Right
        ctx.lineTo(rhombusCX, rhombusCY + (65 * heightFactor)); // Bottom
        ctx.lineTo(rhombusCX - (100 * widthFactor), rhombusCY);   // Left
        ctx.closePath();
        ctx.fill();

        // Blue Circle
        ctx.fillStyle = '#012169'; // Dark Blue
        ctx.beginPath();
        ctx.arc(rhombusCX, rhombusCY, 40, 0, Math.PI * 2);
        ctx.fill();

        // White band (simplified)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(rhombusCX - 40, rhombusCY - 5, 80, 10);
        
        // Stars (simplified)
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(rhombusCX - 20, rhombusCY - 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 15, rhombusCY - 10, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX - 10, rhombusCY + 20, 3, 0, Math.PI * 2);
        ctx.arc(rhombusCX + 25, rhombusCY + 25, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }


    // --- State Drawing Functions ---
    // All drawing functions (drawStartScreen, drawQ1Screen, etc.)
    // remain EXACTLY THE SAME.

    function drawStartScreen() {
        drawText("ARE YOU READY?", canvas.width / 2, 300, 40);
        const btn = { id: 'start', text: 'Fuck no', x: canvas.width / 2 - 150, y: 450, w: 300, h: 80 };
        drawButton(btn.text, btn.x, btn.y, btn.w, btn.h, hoverTarget === btn.id, false, btn.id);
        setRegions([btn]);
    }

    function drawQ1Screen() {
        drawText("ARE YOU HARDCORE.", canvas.width / 2, 300, 32);
        const btnYes = { id: 'yes', text: 'YES', x: canvas.width / 2 - 350, y: 450, w: 300, h: 80 };
        const btnNo = { id: 'no', text: 'NO', x: canvas.width / 2 + 50, y: 450, w: 300, h: 80 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ2Screen() {
        drawText("ARE YOU THE BADDEST OF THEM ALL.", canvas.width / 2, 300, 32);
        const btnYes = { id: 'yes', text: 'YES', x: canvas.width / 2 - 350, y: 450, w: 300, h: 80 };
        const btnNo = { id: 'no', text: 'NO', x: canvas.width / 2 + 50, y: 450, w: 300, h: 80 };
        drawButton(btnYes.text, btnYes.x, btnYes.y, btnYes.w, btnYes.h, hoverTarget === btnYes.id, false, btnYes.id);
        drawButton(btnNo.text, btnNo.x, btnNo.y, btnNo.w, btnNo.h, hoverTarget === btnNo.id, false, btnNo.id);
        setRegions([btnYes, btnNo]);
    }

    function drawQ3Screen() {
        drawText("ARE YOU:", canvas.width / 2, 150, 32);

        const regions = [
            { id: 'internet', x: 150, y: 300, w: 200, h: 250 },
            { id: 'albanian', x: 500, y: 300, w: 200, h: 250 },
            { id: 'lost', x: 850, y: 300, w: 200, h: 250 },
        ];

        drawInternetAddict(regions[0].x, regions[0].y, animationState.frame);

        // Glitching flag logic
        if (Math.random() < 0.15) { 
            drawAlbanianFlag(regions[1].x, regions[1].y, animationState.frame);
        } else {
            drawBrazilianFlag(regions[1].x, regions[1].y, animationState.frame);
        }
        drawText("Secretly Albanian", regions[1].x + 100, regions[1].y + 230, 14);

        drawLost(regions[2].x, regions[2].y, animationState.frame);

        regions.forEach(region => {
            if (hoverTarget === region.id) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.strokeRect(region.x - 10, region.y - 10, region.w + 20, region.h + 20);
            }
        });
        
        setRegions(regions);
    }
    
    function drawEndScreen(message) {
        drawText(message, canvas.width / 2, 300, 32); // Message draws at full opacity
        
        // --- Fade-in and Centering Logic ---
        // Increment alpha over ~2 seconds (120 frames)
        animationState.buttonAlpha = Math.min(1, (animationState.buttonAlpha || 0) + (1 / 120));
        const alpha = animationState.buttonAlpha;

        const btnWidth = 400;
        const btnHeight = 80;
        const btnSpacing = 20;
        const btnX = canvas.width / 2 - btnWidth / 2; // Centered X
        const btnRestartY = 450; // Top button Y
        const btnReadyY = btnRestartY + btnHeight + btnSpacing; // Bottom button Y

        const btnRestart = { id: 'restart', text: 'RESTART', x: btnX, y: btnRestartY, w: btnWidth, h: btnHeight };
        const btnReady = { id: 'ready', text: 'I am ready now', x: btnX, y: btnReadyY, w: btnWidth, h: btnHeight };
        
        // Pass the calculated alpha to drawButton
        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id, alpha);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id, alpha);
        setRegions([btnRestart, btnReady]);
    }

    function drawEndFailScreen() {
        drawEndScreen("Sorry, you can't continue.");
    }
    
    function drawEndInternetScreen() {
        if (imagesLoaded.greyscale === true) {
            ctx.drawImage(imgGreyscale, 0, 0, canvas.width, canvas.height);
        } else if (imagesLoaded.greyscale === 'error') {
            drawText("Error loading Greyscale", canvas.width / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading Greyscale...", canvas.width / 2, 300, 32);
        }
        
        // --- Fade-in and Centering Logic ---
        animationState.buttonAlpha = Math.min(1, (animationState.buttonAlpha || 0) + (1 / 120));
        const alpha = animationState.buttonAlpha;

        const btnWidth = 400;
        const btnHeight = 80;
        const btnSpacing = 20;
        const btnX = canvas.width / 2 - btnWidth / 2; // Centered X
        
        // --- UPDATED Y POSITIONS ---
        // Create 20% (160px) of space below the last button (800 * 0.2 = 160)
        // Last button (Ready) should end at y = 800 - 160 = 640.
        // Last button (Ready) starts at y = 640 - btnHeight = 560.
        const btnReadyY = 560;
        const btnRestartY = btnReadyY - btnSpacing - btnHeight; // 560 - 20 - 80 = 460

        const btnRestart = { id: 'restart', text: 'RESTART', x: btnX, y: btnRestartY, w: btnWidth, h: btnHeight };
        const btnReady = { id: 'ready', text: 'I am ready now', x: btnX, y: btnReadyY, w: btnWidth, h: btnHeight };

        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id, alpha);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id, alpha);
        setRegions([btnRestart, btnReady]);
    }

    function drawEndLostScreen() {
        if (imagesLoaded.butter === true) {
            ctx.drawImage(imgButter, 0, 0, canvas.width, canvas.height);
        } else if (imagesLoaded.butter === 'error') {
            drawText("Error loading butter", canvas.width / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading butter...", canvas.width / 2, 300, 32);
        }
        
        // --- Fade-in and Centering Logic ---
        animationState.buttonAlpha = Math.min(1, (animationState.buttonAlpha || 0) + (1 / 120));
        const alpha = animationState.buttonAlpha;

        const btnWidth = 400;
        const btnHeight = 80;
        const btnSpacing = 20;
        const btnX = canvas.width / 2 - btnWidth / 2; // Centered X

        // --- UPDATED Y POSITIONS ---
        // Create 20% (160px) of space below the last button (800 * 0.2 = 160)
        // Last button (Ready) should end at y = 800 - 160 = 640.
        // Last button (Ready) starts at y = 640 - btnHeight = 560.
        const btnReadyY = 560;
        const btnRestartY = btnReadyY - btnSpacing - btnHeight; // 560 - 20 - 80 = 460

        const btnRestart = { id: 'restart', text: 'RESTART', x: btnX, y: btnRestartY, w: btnWidth, h: btnHeight };
        const btnReady = { id: 'ready', text: 'I am ready now', x: btnX, y: btnReadyY, w: btnWidth, h: btnHeight };

        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id, alpha);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id, alpha);
        setRegions([btnRestart, btnReady]);
    }

    function drawEndAlbanianScreen() {
        if (imagesLoaded.albanian === true) {
            ctx.drawImage(imgAlbanian, 0, 0, canvas.width, canvas.height);
        } else if (imagesLoaded.albanian === 'error') {
            drawText("Error loading albanian", canvas.width / 2, 300, 32, '#ff0000');
        } else {
            drawText("Loading albanian...", canvas.width / 2, 300, 32);
        }
        
        // --- Fade-in and Centering Logic ---
        animationState.buttonAlpha = Math.min(1, (animationState.buttonAlpha || 0) + (1 / 120));
        const alpha = animationState.buttonAlpha;

        const btnWidth = 400;
        const btnHeight = 80;
        const btnSpacing = 20;
        const btnX = canvas.width / 2 - btnWidth / 2; // Centered X

        // --- UPDATED Y POSITIONS ---
        // Create 20% (160px) of space below the last button (800 * 0.2 = 160)
        // Last button (Ready) should end at y = 800 - 160 = 640.
        // Last button (Ready) starts at y = 640 - btnHeight = 560.
        const btnReadyY = 560;
        const btnRestartY = btnReadyY - btnSpacing - btnHeight; // 560 - 20 - 80 = 460

        const btnRestart = { id: 'restart', text: 'RESTART', x: btnX, y: btnRestartY, w: btnWidth, h: btnHeight };
        const btnReady = { id: 'ready', text: 'I am ready now', x: btnX, y: btnReadyY, w: btnWidth, h: btnHeight };

        drawButton(btnRestart.text, btnRestart.x, btnRestart.y, btnRestart.w, btnRestart.h, hoverTarget === btnRestart.id, false, btnRestart.id, alpha);
        drawButton(btnReady.text, btnReady.x, btnReady.y, btnReady.w, btnReady.h, hoverTarget === btnReady.id, false, btnReady.id, alpha);
        setRegions([btnRestart, btnReady]);
    }

    // --- Core Logic ---
    function gameLoop() {
        if (!isGameActive) {
            return; 
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        animationState.frame++;
        
        switch (gameState) {
            case GAME_STATES.START: drawStartScreen(); break;
            case GAME_STATES.Q1: drawQ1Screen(); break;
            case GAME_STATES.Q2: drawQ2Screen(); break;
            case GAME_STATES.Q3: drawQ3Screen(); break;
            case GAME_STATES.END_FAIL: drawEndFailScreen(); break;
            case GAME_STATES.END_INTERNET: drawEndInternetScreen(); break;
            case GAME_STATES.END_LOST: drawEndLostScreen(); break;
            case GAME_STATES.END_ALBANIAN: drawEndAlbanianScreen(); break;
        }
        requestAnimationFrame(gameLoop);
    }
    
    // --- NEW: Event Handlers ---

    /**
     * This function converts on-screen click/touch coordinates to the
     * internal 1200x800 canvas coordinates. This is the key to
     * making the game responsive.
     */
    function getScaledCoords(event) {
        const rect = canvas.getBoundingClientRect();
        // Calculate the ratio between the internal size (1200) and the displayed size
        const scaleX = canvas.width / rect.width; 
        const scaleY = canvas.height / rect.height;

        // Get the x/y of the event relative to the canvas element
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;
        
        return { x, y };
    }

    // This function handles the "click" or "tap" action
    function handlePointerUp(event) {
        if (!isGameActive) return;
        event.preventDefault();
        
        const { x: mouseX, y: mouseY } = getScaledCoords(event);

        const regions = clickRegions[gameState] || [];
        for (const region of regions) {
            if (mouseX >= region.x && mouseX <= region.x + region.w &&
                mouseY >= region.y && mouseY <= region.y + region.h) {
                
                // This logic is identical to your original handleClick
                switch(gameState) {
                    case GAME_STATES.START:
                        if (region.id === 'start') gameState = GAME_STATES.Q1;
                        break;
                    case GAME_STATES.Q1:
                        if (region.id === 'yes') gameState = GAME_STATES.Q2;
                        else if (region.id === 'no') {
                            gameState = GAME_STATES.END_FAIL;
                            animationState.buttonAlpha = 0; // RESET FADE
                        }
                        break;
                    case GAME_STATES.Q2:
                        if (region.id === 'yes') gameState = GAME_STATES.Q3;
                        else if (region.id === 'no') {
                            gameState = GAME_STATES.END_FAIL;
                            animationState.buttonAlpha = 0; // RESET FADE
                        }
                        break;
                    case GAME_STATES.Q3:
                        if (region.id === 'internet') {
                            gameState = GAME_STATES.END_INTERNET;
                            animationState.buttonAlpha = 0; // RESET FADE
                        } else if (region.id === 'lost') {
                            gameState = GAME_STATES.END_LOST;
                            animationState.buttonAlpha = 0; // RESET FADE
                        } else if (region.id === 'albanian') {
                            gameState = GAME_STATES.END_ALBANIAN;
                            animationState.buttonAlpha = 0; // RESET FADE
                        }
                        break;
                    case GAME_STATES.END_FAIL:
                    case GAME_STATES.END_INTERNET:
                    case GAME_STATES.END_LOST:
                    case GAME_STATES.END_ALBANIAN:
                        if (region.id === 'restart') {
                            initializeGame();
                        } else if (region.id === 'ready') {
                            // Navigate to the specified URL
                            window.location.href = 'https://www.shopify.com/de';
                        }
                        break;
                }
                hoverTarget = null; // Clear hover after click
                return; // Exit after processing click
            }
        }
    }
    
    // This function handles mouse hover and touch-down highlighting
    function handlePointerMove(event) {
        if (!isGameActive) return;
        event.preventDefault();

        const { x: mouseX, y: mouseY } = getScaledCoords(event);
        const regions = clickRegions[gameState] || [];
        
        let onTarget = false;
        for (const region of regions) {
             if (mouseX >= region.x && mouseX <= region.x + region.w &&
                 mouseY >= region.y && mouseY <= region.y + region.h) {
                 hoverTarget = region.id;
                 canvas.style.cursor = 'pointer';
                 onTarget = true;
                 break;
             }
        }
        
        if (!onTarget) {
            hoverTarget = null;
            canvas.style.cursor = 'default';
        }
    }
    
    // This function handles the "down" state for touch, giving immediate feedback
    function handlePointerDown(event) {
         if (!isGameActive) return;
        event.preventDefault();
        // We run the same logic as move to set the hoverTarget immediately on tap
        handlePointerMove(event);
    }

    // --- Utility Functions ---
    // drawButton and drawText are unchanged
    
    function drawButton(text, x, y, w, h, isHovered, isDone, id = null, alpha = 1.0) {
        ctx.save(); // Save context state (including globalAlpha)
        ctx.globalAlpha = alpha; // Apply requested transparency

        ctx.strokeStyle = '#fff';
        if(isDone) ctx.fillStyle = '#00ff00';
        else ctx.fillStyle = isHovered ? '#00ff00' : '#555'; /* Neon Green for hover */
        
        // Add subtle shadow for depth
        ctx.shadowColor = isHovered ? '#00ff00' : '#000';
        ctx.shadowBlur = isHovered ? 15 : 0;
        
        ctx.fillRect(x,y,w,h);
        ctx.strokeRect(x,y,w,h);
        
        ctx.shadowBlur = 0; // Reset shadow

        let fontSize = 16;
        if (w < 200) fontSize = 12;
        if (w > 400) fontSize = 24;

        drawText(text, x + w/2, y + h/2 + 4, fontSize, isHovered || isDone ? '#000' : '#fff');
        
        ctx.restore(); // Restore context state (resets globalAlpha to 1)
    }
    
    function drawText(text, x, y, size = 32, color = '#fff') {
            ctx.font = `${size}px "Press Start 2P"`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add a slight text shadow for readability
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.shadowBlur = 2;
            
            ctx.fillText(text, x, y);
            
            // Reset shadows
            ctx.shadowColor = 'transparent';
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;
    }
    
    // --- Start ---
    
    // Remove old mouse/click listeners
    // canvas.addEventListener('click', handleClick);
    // canvas.addEventListener('mousemove', handleMouseMove);

    // Add new "pointer" listeners that work for BOTH mouse and touch
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    
    // Handle case where pointer leaves the canvas (e.g., mouse-out)
    canvas.addEventListener('pointerleave', () => {
        hoverTarget = null;
        canvas.style.cursor = 'default';
    });


    initializeGame();
    gameLoop();

</script>

</body>
</html>





